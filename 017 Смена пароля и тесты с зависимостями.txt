Инкапсуляция операции в сущности

Если мы проверки выносим наружу нашей сущности нашего пользователя,
то у нас возникает несколько недостатков:
1) Кто угодно может вызвать метод changePassword, передавая туда новый хеш
при этом забыв произвести все эти проверки
2) Эти проверки нужно будет тестировать в хендлере и мы не можем из протестировать
написав тест для юзера.
3) Если делаем проверки снаружи, то нам приходится делать геттеры с помощью которых
мы должны эти элементы для проверок получить. Соответсвенно у нас получается утечка информаци.
мы добавляем геттеры чтобы получить некоторые данные из пользователя и чтобы обработать их
как-то напрямую вместо того чтобы юзер сам обрабатывал эти данные.

Чтобы избавиться от этих недочетов эти проверки можно поместить внутрь нашего пользователя.

----------------------------------------------------

Механика создания стабов в PHPUnit

$hasher = $this->createStub(PasswordHasher::class);
        $hasher->method('validate')->willReturn($valid);
        $hasher->method('hash')->willReturn($hash);

eval('class PasswordHasher4234werwer extends PasswordHasher {
    use ...

}');

$hasher = (new \ReflectionClass(PasswordHasher4234werwer::class))->newInstanceWithoutConstructor();

$user->changePassword(
    'old-password',
    'new-password',
    $hasher
);

Используя метод createStub мы теперь можем генерировать любой объект из любого класса
или любого интерфейса и при этом на лету настраивать как он должен себя вести и какие
значения должен возвращать из своих методов которые в нем находятся.

И в этом случае нам очень полезно работать с маленькими классами с малым числом методов,
т.к. мы с вами пишем разные сервисы и потом где-нибудь их используем, то в каком нибудь
Tokenizer есть всего 1 метод, в Passwrodhasher есть всего 2 метода, то в этом случае их
очень легко переопределять, создавать изних заглушки стабы, чтобы их можно было использовать
в разных тестах.

Если мы бхотели создать юнит тест для хендлера, то в этом тесте мы бы могли создать заглушку
UserRepository, PasswrodHasher, Flusher которые не будут ничего делать. И потом создать объект
хендер передав туда вот эти три заглушки и после этого вызвать метод хендл. Передавая туда
разные команды. И уже проверять либо этот метод хендл нормально выполниться и приэтом ничего
не произойдет, либо этот метод вернет исключение.


----------------------------------------------------

Отличие моков от стабов

$hasher = $this->createStub(PasswordHasher::class);
$hasher->method('validate')->willReturn(false);
$hasher->method('hash')->willReturn($hash = 'new-hash');

$hasher = $this->createMock(PasswordHasher::class);
$hasher->expects($this->once())->method('validate')->willReturn(false);

PHPUnit будет проверять через expects, что метод обязательно вызывается.
В этом и разница между стабами и моками.

Стаб - это просто заглушка которая должна возвращать просто какй-то результат и все. Примитивная подмена
какго-нибудь объекта на заглушку.

Мок - более умный и проверяет как он вызывается, с какими элементами, с какими параметрами.

----------------------------------------------------

Нужно бдить и на стороне сервера осуществлять все проверки, которые нам нужны и при этом
не опираясь на то что, где-нибудь на фронтенде там что-то можно спрятать и пользователь до этого не дойдет.



----------------------------------------------------

Много где слышал, что хорошей практикой является создание собственных классов исключений. Почему вы не практикуете это?

Это удобно если есть необходимость их по-разному отлавливать и обрабатывать.
Например, если мы пишем клиент для API, то в нём есть смысл делать свои отдельные ConnectionException и ResponseException,
чтобы дать возможность отлавливать их разными блоками catch {}.

Или чтобы в тех же тестах или переводов указывать имена классов вместо текста:

$this->expectException(ResettingNotRequestedException::class);

В нашем же случае мы все доменные исключения будем отлавливать и отображать одинаково.
Так что особой пользы добавление куч классов исключений нам не принесёт.
















